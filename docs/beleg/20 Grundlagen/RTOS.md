#RTOS
Die Abkürzung RTOS steht für Real- Time- Operation System. Echtzeitbetriessysteme werden im Gegensatz zu Time- Sharing Betriebssystemen wie Unix eingestzt um eine möglichst hohe konsistenz bei der Umsetzung von Zeitkritischen Anwendungen zu erreichen. Prinzipiell werden zwischen harten und weichen Echtzeitbetriebssystemen entschieden. Die Übergänge sind fließend zwischen ihnen, sie werden aber an bestimmten System- Charakteristiken unterschieden. Generell sind harte Echtzeitbetriebssysteme schwerer umzuestzen als weiche. Bei Harten Echtzeitbetriebssystemen gilt das reißen einer einzigen Deadline als Systemversagen während bei weichen Echtzeitbetriessystemen ledigdlich der Performanz des Systems sinkt und ein gewisser Grad als akzeptabel gilt. Generell arbeitet ein hartes Echtzeitbetriebssystemen mit kleinen Dateien während ein weiches Echtzeitbetriebssystemen mit eher großen arbeitet. Aus der ersten Bedingung leitet sich eine weitere Egenschaft ab. Bei harten Echtzeitbetriebssystemen muss die Belastung des Systems zu allen Zeiten bekannt sein. Eine sehr instinktive Eigenschaft, denn wenn die Belastung nicht korrekt vorhergesagt wurde, kann es zum reißen von Deadlines kommen. Weiche Systeme kommen hingegen auch mit mit unerwartet großen Belastungen gut zurecht. Entsprechend sollten harte Echtzeitbetriebssysteme ihre Task gekapselt von anderen nicht Echtzeit Tasks oder weichen Echtzeit -tasks bearbeiten. Dem kommt zu gute das harte Echtzeitbetriebssystem Tasks in der Regel auf ihrem eigenen festen Speicherbereich arbeiten, um eine Intererrenz mit den oben gennanten zu vermeiden. Die Nachteile sind ersichtlich, die Informationen für harte echtzeit Tasks müssen bereits bei erstellung bekannt sein und reservieren bereits bei der ersten ausführung ihren vollständigen Speicherbedarf. Dies ist eine große Herrausforderung für den Designer, daher werden harte Echtzeittasks häufig kleiner gehalten und nur dort eingesetzt wo eine schnelle vorhersehbare Reaktion erforderlich ist. Ein weiterer großer Unterschied liegt im error Handling der beiden Systeme: Wenn weiche Echtzeitbetriebssysteme eine Deadline verfehlen dann sinkt ihre Performance, harte Echtzeitbetriebssystem stoppen erstmal, und versuchen den Task neu zu Starten. Also ihren Fehler zu korrigieren. 
In einem Echtzeitbetriebssystem gibt es verschiedene Arten des Schedulings. Als Beispiel sei hier das Scheduling nach Priorität genannt. Ein Designer versieht jeden Task mit einer Prioriät und der Scheduler wählt dabei die Task mit der höchsten Priorität in der Queue aus und versetzt sie in den Ready Status. 	Am Scheduler müsste man ansetzen um ein hybrides System zu schaffen, solange die Speicherintegrität der Echtzeittasks garantiert werden kann, sobald Speicher Ausgelagert werden muss ist dann die Deadline unter umständen in Gefahr. 
In diesem Projekt benutzen wir das sehr leichtgewichtige FreeRTOS als hartes Echtzeitbetriebssystem. In den folgenden Kapiteln zu dieser Thematik werde ich darauf eingehen ich welcher Form FreeRTOS in das Projekt integriert wurde, welche Funktionen implementiert wurden und welhe Aufgaben das RTOS dadurch übernehmen soll. Das Kapitel wird mit einem Fazit zur Testung des RTOS beendet. 
- S
#Grundlagen FreeRTOS
FreeRTOS ist eines der erfolgreichsten Echtzeitbetriebssysteme am Markt. Sein Code ist vollständig OpenSource dabei aber zugleich von einer professionellen Gruppe maintained und weiterentwickelt. Es kann sowohl kommerziell als auch nicht- kommerziell verwendet werden. Kosten entstehen erst durch einen Service der von der Eigentümerfirma Real Time Engineers ltd. gekauft werden kann. Wie schon erwähnt ist FreeRTOS sehr leichtgewichtig und bietet dabei aber schon eine große Menge an Funktionen. 
## Timings
Eine der wichtigsten Eigenschaften von Betriebssystemen ist der Timer. In FreeRTOS wird dies über den Variablentyp TickType_t implementiert. Abhängig von Chip und Port wird diese anders definiert. In dem Port für den ESP8266 Microcontroller wird dieser Datentyp als unsigned int32 implementiert. Die Dauer eines Ticks lässt sich frei wählen. Am Ende eines Ticks hat der Scheduler die Möglichkeit einen neuen Task in den Runningstate zu versetzen. Der Standard für diesen Wert sind 10ms je Tick Interrupt (100 Hz).
## Task States
FreeRTOS kennt vier Task-states. Wobei drei gerne zu dem Super State „Not Running“ zusammengefasst werden. Ein Task kann zu jedem Zeitpunkt immer nur in einem State sein. In FreeRTOS wechseln die Tasks dabei beim aufrufen der API von einem State zu einem anderen. Zu beachten ist das nur der Scheduler einen Task in den Running State versetzen kann und nie ein Task selbst.
### Running
Der Task hat die Ressource und rechnet.
### Blocking
Ein Task im Blocking State wartet auf ein Syncronisationsevent oder ein Zeitevent. Danach steht er dem Scheduler wieder zur Verfügung.
### Ready
Tasks im Ready State sind Tasks die gerade nicht die Ressource haben, dabei aber weder blockiert nocht pausiert sind. 
### Suspended
Der Task kann nicht vom Scheduler ausgewählt werden. Er wird niemals in den Running State versetzt bis die Funktion vTaskResume(task_ptr*) aufgerufen wurde.
## Scheduling
Standardmäßig verwendet FreeRTOS Fixed Priority Preemptive Scheduling with Time Slicing. Dies ist auch die meist benutzte Scheduling Form von Echtzeitbetriebssystemen. 
Fixed Priority: Der Scheduler ist nicht in der Lage die Priorität von Tasks zu ändern. Zusätzlich verhinder der Scheduler aber auch nicht das Tasks ihre eigene Priorität oder die Prioriät von anderen Tasks verändern.
Pre- emptive: 	Der Scheduler wird immer den Task der im Ready State ist in den Running State versetzen und den gerade laufenden Task unterbrechen. Der gerade laufende Task wird dabei in den Ready State versetzt und wartet auf die Ressource. 
